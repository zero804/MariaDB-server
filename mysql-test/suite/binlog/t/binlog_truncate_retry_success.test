# ==== Purpose ====
#
# Test verifies that tc-heuristic-recover=BINLOG_TRUNCATE can be retried.
#
# ==== Implementation ====
#
# Steps:
#    0 - Create a table in Innodb storage engine. Insert a row into the table.
#    1 - Do an another DML into the table, and simulate a crash in the middle
#        of DML commit, so that DML is present in binary log but not committed in
#        the storage engine.
#    2 - Restart the server using --tc-heuristic-recover=BINLOG_TRUNCATE
#        simulating an erroor during the binary log rollback operation.
#	 Verify appropriate error is reported in the error log.
#    3 - Remove the simulation retry the --tc-heuristic-recver=BINLOG_TRUNCATE.
#        Verify that binary log gets truncated as expected.
#    4 - Verify that global gtid state is according to the rolled back
#        transaction.
# ==== References ====
#
# MDEV-21117: --tc-heuristic-recover=rollback is not replication safe


--source include/have_innodb.inc
--source include/not_embedded.inc
--source include/have_log_bin.inc
--source include/have_debug.inc
--source include/have_debug_sync.inc
--source include/have_binlog_format_row.inc

call mtr.add_suppression("Can't init tc log");
call mtr.add_suppression("Aborting");
call mtr.add_suppression("tc-heuristic-recover: Failed to open the binlog");
call mtr.add_suppression("Heuristic BINLOG_TRUNCATE crash recovery failed. Error:");

RESET MASTER;

CREATE TABLE t1 (a INT PRIMARY KEY, b MEDIUMTEXT) ENGINE=Innodb;
INSERT INTO t1 VALUES (1,'dummy');
connect(master1,localhost,root,,);
connect(master2,localhost,root,,);

--connection master1
SET DEBUG_SYNC= "commit_after_release_LOCK_log SIGNAL con1_ready WAIT_FOR con1_go";
send INSERT INTO t1 VALUES (2,'dummy');

--connection master2
SET DEBUG_SYNC= "now WAIT_FOR con1_ready";
--echo "List of binary logs"
--source include/show_binary_logs.inc
--write_file $MYSQLTEST_VARDIR/tmp/mysqld.1.expect
wait
EOF

--source include/kill_mysqld.inc
--source include/wait_until_disconnected.inc
#
# Server restart
#
# The purpose of debug_dbug's "d,skip_new_binlog_create" is to avoid
# binlog rotation at the end of heuristic recovery\footnote{When the
# simulated error occured for a real user she would have to manually
# remove the created binlog file, if retry makes sense}.
--error 1
--exec $MYSQLD_LAST_CMD  --tc-heuristic-recover=BINLOG_TRUNCATE --debug-dbug=d,fault_injection_opening_binlog,skip_new_binlog_create > $MYSQLTEST_VARDIR/log/mysqld.1.err 2>&1
--source include/wait_until_disconnected.inc

--error 1
--exec $MYSQLD_LAST_CMD  --tc-heuristic-recover=BINLOG_TRUNCATE > $MYSQLTEST_VARDIR/log/mysqld.1.err 2>&1
--source include/wait_until_disconnected.inc

--append_file $MYSQLTEST_VARDIR/tmp/mysqld.1.expect
restart:
EOF

connection default;
--enable_reconnect
--source include/wait_until_connected_again.inc

# Check error log for correct messages.
let $log_error_= `SELECT @@GLOBAL.log_error`;
if(!$log_error_)
{
    # MySQL Server on windows is started with --console and thus
    # does not know the location of its .err log, use default location
    let $log_error_ = $MYSQLTEST_VARDIR/log/mysqld.1.err;
}
--let SEARCH_FILE=$log_error_
--let SEARCH_RANGE=-50000
--let SEARCH_PATTERN=tc-heuristic-recover: Truncated binlog File: \.\/master\-bin\.000001 of Size:[0-9]*, to Position *
--source include/search_pattern_in_file.inc

--echo "One row should be present in table"
SELECT COUNT(*) FROM t1;

--echo "Two gtids should be present 0-1-2, one for CREATE and the other for INSERT"
SELECT @@GLOBAL.gtid_current_pos;

DROP TABLE t1;
--echo "Three gtids should be present 0-1-3 after table 't1' is dropped."
SELECT @@GLOBAL.gtid_binlog_state;

--disconnect master1
--disconnect master2

--echo End of the tests
